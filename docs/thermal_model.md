# Thermal Model (v0.00.1)

## Tower state variables

Each tower tracks:

- `heat`: current thermal level
- `capacity`: max heat before forced disable
- `dissipation_rate`: passive cooling per second
- `heat_per_shot`: heat generated by each shot
- `recovery_threshold`: heat level under which tower can fire again

## Update equations

Per simulation step (`dt`):

1. **Passive cooling**
   - `heat = max(0, heat - dissipation_rate * dt)`
2. **Shot event**
   - if tower can fire and target exists: `heat += heat_per_shot`
3. **Overheat transition**
   - if `heat >= capacity`: state becomes `overheated` and tower fire disables
4. **Recovery transition**
   - if `overheated` and `heat <= recovery_threshold`: state returns to `active`

## Visual encoding

No text labels in gameplay. Heat is encoded as color:

- cool: blue
- elevated: yellow
- critical: red

Long-press applies temporary emphasis pulse to aid diagnosis without introducing text UI.

## WASMUTABLE refinement hook

Thermal constants are isolated in a single parameter object so future rule mutation can atomically swap model coefficients at runtime without changing update loops.

In the Godot prototype, `WasmutableRules` owns the active thermal profile and exposes `get_profile_copy()` + `mutate_for_pressure_cycle()` so tower instances can read immutable snapshots during placement/update.

At runtime, periodic WASMUTABLE pressure cycles raise `heat_per_shot` and lower `dissipation_rate`, forcing continuous tactical refinement during a run.

Merge note: both `android/BurzenTD/scripts/main.gd` and `android/BurzenTD/app/src/main/java/com/burzen/td/GameView.kt` should preserve the same overheat/recovery and WASMUTABLE coefficient-shift semantics.
